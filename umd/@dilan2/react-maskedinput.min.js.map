{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap ac5b4bc1add506afd159","webpack:///./src/index.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}","webpack:///./node_modules/inputmask-core/lib/index.js"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE_2__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","KEYCODE_Z","KEYCODE_Y","getSelection","el","start","end","undefined","selectionStart","selectionEnd","focus","rangeEl","createTextRange","clone","duplicate","moveToBookmark","document","selection","createRange","getBookmark","setEndPoint","text","length","e","MaskedInput","_onChange","maskValue","_this","mask","getValue","incomingValue","target","value","_updateMaskSelection","setValue","_getDisplayValue","_updateInputSelection","props","onChange","_onKeyDown","ctrlKey","metaKey","keyCode","shiftKey","isUndo","preventDefault","undo","isRedo","redo","key","backspace","_onKeyPress","altKey","input","data","_onPaste","paste","clipboardData","getData","setTimeout","componentWillMount","options","pattern","formatCharacters","placeholderChar","InputMask","componentWillReceiveProps","nextProps","emptyValue","setPattern","getRawValue","componentWillUpdate","nextState","_updatePattern","componentDidUpdate","prevProps","setSelectionRange","collapse","moveStart","moveEnd","select","setSelection","_keyPressPropName","navigator","userAgent","match","_getEventHandlers","_ref","onKeyDown","onPaste","blur","render","_this2","maxLength","eventHandlers","_props","_props$size","size","_props$placeholder","placeholder","_props2","cleanedProps","_objectWithoutProperties","inputProps","ref","r","__WEBPACK_IMPORTED_MODULE_0_react___default","a","createElement","React","Component","defaultProps","extend","dest","src","keys","copy","obj","DIGIT_RE","LETTER_RE","ALPHANNUMERIC_RE","DEFAULT_PLACEHOLDER_CHAR","DEFAULT_FORMAT_CHARACTERS","*","validate","char","test","1","A","transform","toUpperCase","#","Pattern","source","isRevealingMask","firstEditableIndex","lastEditableIndex","_editableIndices","_parse","Error","merged","chars","mergeFormatCharacters","sourceChars","split","patternIndex","push","formatValue","valueBuffer","Array","valueIndex","isEditableIndex","isValidAtIndex","index","format","selectionBefore","valueBefore","inputIndex","_historyIndex","_history","splice","_lastOp","_lastSelection","lastOp","initialState","slice","charAt","substring","historyItem","startUndo","pop","join","_resetHistory","rawValue"],"mappings":"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","file":"@dilan2/react-maskedinput.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MaskedInput\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"MaskedInput\"] = factory(root[\"React\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ac5b4bc1add506afd159","import React from 'react'\nimport PropTypes from 'prop-types'\nimport InputMask from 'inputmask-core'\n\nlet KEYCODE_Z = 90\nlet KEYCODE_Y = 89\n\nfunction isUndo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Y : KEYCODE_Z)\n}\n\nfunction isRedo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Z : KEYCODE_Y)\n}\n\nfunction getSelection (el) {\n  let start, end\n  if (el.selectionStart !== undefined) {\n    start = el.selectionStart\n    end = el.selectionEnd\n  }\n  else {\n    try {\n      el.focus()\n      let rangeEl = el.createTextRange()\n      let clone = rangeEl.duplicate()\n\n      rangeEl.moveToBookmark(document.selection.createRange().getBookmark())\n      clone.setEndPoint('EndToStart', rangeEl)\n\n      start = clone.text.length\n      end = start + rangeEl.text.length\n    }\n    catch (e) { /* not focused or not visible */ }\n  }\n\n  return { start, end }\n}\n\nfunction setSelection(el, selection) {\n  try {\n    if (el.selectionStart !== undefined) {\n      el.focus()\n      el.setSelectionRange(selection.start, selection.end)\n    }\n    else {\n      el.focus()\n      let rangeEl = el.createTextRange()\n      rangeEl.collapse(true)\n      rangeEl.moveStart('character', selection.start)\n      rangeEl.moveEnd('character', selection.end - selection.start)\n      rangeEl.select()\n    }\n  }\n  catch (e) { /* not focused or not visible */ }\n}\n\nclass MaskedInput extends React.Component {\n  static propTypes = {\n    mask: PropTypes.string.isRequired,\n\n    formatCharacters: PropTypes.object,\n    placeholderChar: PropTypes.string\n  }\n\n  static defaultProps = {\n    value: ''\n  }\n\n  componentWillMount() {\n    let options = {\n      pattern: this.props.mask,\n      value: this.props.value,\n      formatCharacters: this.props.formatCharacters,\n      selection: this.props.selection || {start:0, end:0}\n    }\n    if (this.props.placeholderChar) {\n      options.placeholderChar = this.props.placeholderChar\n    }\n    this.mask = new InputMask(options)\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (this.props.mask !== nextProps.mask && this.props.value !== nextProps.mask) {\n      // if we get a new value and a new mask at the same time\n      // check if the mask.value is still the initial value\n      // - if so use the nextProps value\n      // - otherwise the `this.mask` has a value for us (most likely from paste action)\n      if (this.mask.getValue() === this.mask.emptyValue) {\n        this.mask.setPattern(nextProps.mask, {value: nextProps.value})\n      }\n      else {\n        this.mask.setPattern(nextProps.mask, {value: this.mask.getRawValue()})\n      }\n    }\n    else if (this.props.mask !== nextProps.mask) {\n      this.mask.setPattern(nextProps.mask, {value: this.mask.getRawValue()})\n    }\n    else if (this.props.value !== nextProps.value) {\n      this.mask.setValue(nextProps.value)\n    }\n  }\n\n  componentWillUpdate(nextProps, nextState) {\n    if (nextProps.mask !== this.props.mask) {\n      this._updatePattern(nextProps)\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.mask !== this.props.mask && this.mask.selection.start) {\n      this._updateInputSelection()\n    }\n  }\n\n  _updatePattern(props) {\n    this.mask.setPattern(props.mask, {\n      value: this.mask.getRawValue(),\n      selection: getSelection(this.input)\n    })\n  }\n\n  _updateMaskSelection() {\n    this.mask.selection = getSelection(this.input)\n  }\n\n  _updateInputSelection() {\n    setSelection(this.input, this.mask.selection)\n  }\n\n  _onChange = (e) => {\n    // console.log('onChange', JSON.stringify(getSelection(this.input)), e.target.value)\n\n    let maskValue = this.mask.getValue()\n    let incomingValue = e.target.value\n    if (incomingValue !== maskValue) { // only modify mask if form contents actually changed\n      this._updateMaskSelection()\n      this.mask.setValue(incomingValue) // write the whole updated value into the mask\n      e.target.value = this._getDisplayValue() // update the form with pattern applied to the value\n      this._updateInputSelection()\n    }\n\n    if (this.props.onChange) {\n      this.props.onChange(e)\n    }\n  }\n\n  _onKeyDown = (e) => {\n    // console.log('onKeyDown', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    if (isUndo(e)) {\n      e.preventDefault()\n      if (this.mask.undo()) {\n        e.target.value = this._getDisplayValue()\n        this._updateInputSelection()\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n      return\n    }\n    else if (isRedo(e)) {\n      e.preventDefault()\n      if (this.mask.redo()) {\n        e.target.value = this._getDisplayValue()\n        this._updateInputSelection()\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n      return\n    }\n\n    if (e.key === 'Backspace') {\n      e.preventDefault()\n      this._updateMaskSelection()\n      if (this.mask.backspace()) {\n        let value = this._getDisplayValue()\n        e.target.value = value\n        if (value) {\n          this._updateInputSelection()\n        }\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n    }\n  }\n\n  _onKeyPress = (e) => {\n    // console.log('onKeyPress', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    // Ignore modified key presses\n    // Ignore enter key to allow form submission\n    if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') { return }\n\n    e.preventDefault()\n    this._updateMaskSelection()\n    if (this.mask.input((e.key || e.data))) {\n      e.target.value = this.mask.getValue()\n      this._updateInputSelection()\n      if (this.props.onChange) {\n        this.props.onChange(e)\n      }\n    }\n  }\n\n  _onPaste = (e) => {\n    // console.log('onPaste', JSON.stringify(getSelection(this.input)), e.clipboardData.getData('Text'), e.target.value)\n\n    e.preventDefault()\n    this._updateMaskSelection()\n    // getData value needed for IE also works in FF & Chrome\n    if (this.mask.paste(e.clipboardData.getData('Text'))) {\n      e.target.value = this.mask.getValue()\n      // Timeout needed for IE\n      setTimeout(() => this._updateInputSelection(), 0)\n      if (this.props.onChange) {\n        this.props.onChange(e)\n      }\n    }\n  }\n\n  _getDisplayValue() {\n    let value = this.mask.getValue()\n    return value === this.mask.emptyValue ? '' : value\n  }\n\n  _keyPressPropName() {\n    if (typeof navigator !== 'undefined') {\n      return navigator.userAgent.match(/Android/i)\n      ? 'onBeforeInput'\n      : 'onKeyPress'\n    }\n    return 'onKeyPress'\n  }\n\n  _getEventHandlers() {\n    return {\n      onChange: this._onChange,\n      onKeyDown: this._onKeyDown,\n      onPaste: this._onPaste,\n      [this._keyPressPropName()]: this._onKeyPress\n    }\n  }\n\n  focus() {\n    this.input.focus()\n  }\n\n  blur() {\n    this.input.blur()\n  }\n\n  render() {\n    let ref = r => { this.input = r }\n    let maxLength = this.mask.pattern.length\n    let value = this._getDisplayValue()\n    let eventHandlers = this._getEventHandlers()\n    let { size = maxLength, placeholder = this.mask.emptyValue } = this.props\n\n    let { placeholderChar, formatCharacters, ...cleanedProps } = this.props // eslint-disable-line no-unused-vars\n    let inputProps = { ...cleanedProps, ...eventHandlers, ref, maxLength, value, size, placeholder }\n    return <input {...inputProps} />\n  }\n}\n\nexport default MaskedInput\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 2\n// module chunks = 0","'use strict'\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/inputmask-core/lib/index.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}